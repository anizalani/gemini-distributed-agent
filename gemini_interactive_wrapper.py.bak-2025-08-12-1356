#!/usr/bin/env python3
import os
import sys
import subprocess
import argparse
import logging
import datetime
import hashlib
import readline

# --- Path Setup ---
AGENT_DIR = os.path.dirname(__file__)
sys.path.append(AGENT_DIR)
try:
    import db_utils
except ImportError as e:
    sys.exit(f"Fatal Error: Could not import db_utils.py. Details: {e}")

# --- Constants ---
COMMAND_TIMEOUT = 300
NVM_NODE_BIN = "/home/ubuntu/.nvm/versions/node/v20.19.4/bin"
GEMINI_EXEC = os.path.join(NVM_NODE_BIN, "gemini")

# --- Logging Setup ---
LOG_FILE = os.path.join(AGENT_DIR, "interactive_wrapper.log")
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(message)s', handlers=[logging.FileHandler(LOG_FILE)])

def generate_task_id(prompt):
    hostname = os.uname().nodename
    timestamp = datetime.datetime.now().strftime('%Y%m%d-%H%M%S')
    prompt_hash = hashlib.md5(prompt.encode()).hexdigest()[:8]
    return f"interactive-{hostname}-{timestamp}-{prompt_hash}"

def get_command_from_gemini(prompt, key_name, api_key):
    logging.info(f"Getting command from Gemini for key {key_name}")
    env = os.environ.copy()
    env["GEMINI_API_KEY"] = api_key
    env["PATH"] = f"{NVM_NODE_BIN}:{env.get('PATH', '')}"
    try:
        result = subprocess.run([GEMINI_EXEC], input=prompt, capture_output=True, text=True, env=env, timeout=COMMAND_TIMEOUT)
        if result.returncode == 0:
            return result.stdout.strip()
        logging.error(f"Gemini CLI failed to generate command. Stderr: {result.stderr.strip()}")
        return None
    except subprocess.TimeoutExpired:
        logging.error("Gemini CLI timed out while generating command.")
        return None

def execute_and_stream_command(cur, command_log_id, command_to_run):
    logging.info(f"Executing confirmed command (Log ID: {command_log_id})")
    env = os.environ.copy()
    env["PATH"] = f"{NVM_NODE_BIN}:{env.get('PATH', '')}"
    full_response, stderr_output = [], []
    success, returncode = False, -1
    try:
        cur.execute("UPDATE command_log SET status = 'running', command_start_timestamp = NOW() WHERE id = %s;", (command_log_id,))
        cur.connection.commit()
        process = subprocess.Popen(command_to_run, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, env=env)
        for line in iter(process.stdout.readline, ''):
            print(line, end='')
            full_response.append(line)
        stderr_lines = process.stderr.readlines()
        stderr_output.extend(stderr_lines)
        returncode = process.wait(timeout=COMMAND_TIMEOUT)
        success = returncode == 0
    except subprocess.TimeoutExpired:
        stderr_output.append(f"Command timed out after {COMMAND_TIMEOUT} seconds.")
        logging.error(stderr_output[-1])
    final_response_str = "".join(full_response)
    final_stderr_str = "".join(stderr_output).strip()
    db_utils.log_command_output(cur, command_log_id, final_response_str, final_stderr_str, returncode, None, success)
    cur.execute("UPDATE command_log SET status = %s, command_end_timestamp = NOW() WHERE id = %s;", ('completed' if success else 'failed', command_log_id))
    cur.connection.commit()

def process_interactive_prompt(cur, task_id, prompt, key_name, api_key, is_agentic):
    original_prompt = prompt
    while True:
        print("[Agent] Getting command from Gemini...")
        command_to_run = get_command_from_gemini(prompt, key_name, api_key)
        if not command_to_run:
            print("[Agent] Could not get a command from Gemini. Please try again.", file=sys.stderr)
            return

        if is_agentic:
            print(f"[Agent] Running command in agentic mode:\n  {command_to_run}")
            command_log_id = db_utils.log_command(cur, task_id, original_prompt, "", command_to_run, "superuser", True, "agentic_cli")
            cur.connection.commit()
            execute_and_stream_command(cur, command_log_id, command_to_run)
            break

        print(f"\n[Agent] The following command was generated:\n  {command_to_run}")
        try:
            user_input = input("> Approve? [y/n/edit]: ").strip().lower()
        except (EOFError, KeyboardInterrupt):
            user_input = 'n'
        
        if user_input == 'y':
            command_log_id = db_utils.log_command(cur, task_id, original_prompt, "", command_to_run, "superuser", True, "interactive_cli")
            cur.connection.commit()
            execute_and_stream_command(cur, command_log_id, command_to_run)
            break
        elif user_input == 'n':
            print("[Agent] Command execution denied.")
            db_utils.log_command(cur, task_id, original_prompt, "User denied execution.", command_to_run, "superuser", False, "interactive_cli")
            cur.connection.commit()
            break
        else:
            print("[Agent] Treating input as an edited prompt.")
            prompt = user_input

def start_interactive_session(conn, redis_conn, is_agentic):
    mode = "Agentic" if is_agentic else "Interactive"
    print(f"Starting {mode} Gemini session. Type 'exit' or 'quit' to end.")
    logging.info(f"Starting {mode} session.")
    try:
        with conn.cursor() as cur:
            key_info = db_utils.get_available_key(cur, redis_conn)
            if not key_info:
                sys.exit("Error: No available API keys. Please check the database.")
            key_name, api_key = key_info
            print(f"Using API Key: {key_name}")
            session_task_id = generate_task_id("interactive-session")
            db_utils.get_or_create_task(cur, session_task_id)
            conn.commit()
            while True:
                try:
                    prompt = input("gemini> ").strip()
                    if not prompt: continue
                    if prompt.lower() in ['exit', 'quit']: break
                    db_utils.throttle_if_needed(cur, key_name)
                    process_interactive_prompt(cur, session_task_id, prompt, key_name, api_key, is_agentic)
                except (EOFError, KeyboardInterrupt):
                    break
    finally:
        print("\nExiting session.")
        logging.info("Session ended.")

def main():
    parser = argparse.ArgumentParser(description="Gemini Interactive Wrapper with DB Logging")
    parser.add_argument('--agentic', action='store_true', help="Enable agentic mode to bypass confirmation prompts.")
    args = parser.parse_args()
    conn = db_utils.get_db_connection()
    if not conn:
        sys.exit("Fatal Error: Could not connect to the database.")
    redis_conn = db_utils.get_redis_connection()
    try:
        start_interactive_session(conn, redis_conn, args.agentic)
    finally:
        if conn:
            conn.close()

if __name__ == "__main__":
    main()
