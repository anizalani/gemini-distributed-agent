import os
import csv
import json
import pytz
import psycopg2
from io import StringIO
from datetime import datetime
from urllib.parse import urlencode, parse_qs, urlparse, urlunparse

from dotenv import load_dotenv
from flask import (
    Flask, request, Response, render_template_string,
    send_from_directory, url_for, redirect
)

# --- Configuration ---
dotenv_path = os.path.join(os.path.dirname(__file__), '.postgres.env')
load_dotenv(dotenv_path=dotenv_path)

DB_NAME = os.getenv("POSTGRES_DB")
DB_USER = os.getenv("POSTGRES_USER")
DB_PASS = os.getenv("POSTGRES_PASSWORD")
DB_HOST = os.getenv("POSTGRES_HOST")
DB_PORT = os.getenv("POSTGRES_PORT")

TARGET_TZ = pytz.timezone(os.getenv("APP_TIMEZONE", "America/Chicago"))

# --- Flask App ---
app = Flask(__name__)

# Prefer /gemma_logs, fallback to /logs
PRIMARY_LOGS_DIR = os.path.join(app.root_path, 'gemma_logs')
SECONDARY_LOGS_DIR = os.path.join(app.root_path, 'logs')
LOGS_DIR = PRIMARY_LOGS_DIR if os.path.isdir(PRIMARY_LOGS_DIR) else SECONDARY_LOGS_DIR

# --- Helpers ---
def get_db_connection():
    try:
        return psycopg2.connect(
            dbname=DB_NAME, user=DB_USER, password=DB_PASS, host=DB_HOST, port=DB_PORT
        )
    except psycopg2.OperationalError as e:
        print(f"Database connection failed: {e}")
        return None

def convert_to_local_time(dt):
    if dt and isinstance(dt, datetime):
        # Treat DB datetimes as UTC unless they already have tzinfo
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=pytz.utc)
        return dt.astimezone(TARGET_TZ).strftime('%Y-%m-%d %H:%M:%S %Z')
    return dt

def fmt_bool(b):
    return "✓" if b else "✗"

def badge(text, color):
    return f'<span style="padding:.15rem .5rem;border-radius:.5rem;background:{color};color:#fff;font-weight:600;">{text}</span>'

def set_qs(url, **updates):
    parts = urlparse(url)
    q = parse_qs(parts.query)
    for k, v in updates.items():
        if v is None and k in q:
            del q[k]
        elif v is not None:
            q[k] = [str(v)]
    new_q = urlencode(q, doseq=True)
    return urlunparse((parts.scheme, parts.netloc, parts.path, parts.params, new_q, parts.fragment))

# --- HTML Base Template ---
HTML_BASE = """
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gemini Agent - {{ title }}</title>
{% if refresh_seconds %}
<meta http-equiv="refresh" content="{{ refresh_seconds }}">
{% endif %}
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
 body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; background:#f7f7fb; color:#222; margin:0; }
 nav { background:#222; display:flex; gap:1rem; padding:0.75rem 1rem; position:sticky; top:0; }
 nav a { color:#fff; text-decoration:none; font-weight:600; padding:.4rem .6rem; border-radius:.4rem; }
 nav a.active, nav a:hover { background:#444; }
 .container { max-width: 95%; margin: 1.25rem auto; }
 h1 { margin: 0 0 1rem 0; color:#333; }
 table { width:100%; border-collapse:collapse; background:#fff; box-shadow:0 2px 15px rgba(0,0,0,.06); }
 th, td { padding:12px 14px; border-bottom:1px solid #eaeaea; vertical-align:top; }
 thead { background:#2979ff; color:#fff; }
 tr:nth-child(even) { background:#fafafa; }
 .no-data { padding:2rem; text-align:center; color:#777; }
 .toolbar { margin:.6rem 0 1rem 0; display:flex; flex-wrap:wrap; gap:.5rem; align-items:center; }
 .toolbar input, .toolbar select { padding:.35rem .5rem; }
 .toolbar button, .btn { padding:.4rem .6rem; border:none; background:#2979ff; color:#fff; border-radius:.35rem; cursor:pointer; }
 .btn.secondary { background:#6c757d; }
 .btn.link { background:transparent; color:#2979ff; text-decoration:underline; }
 pre, code { background:#111; color:#eee; padding: .75rem; border-radius:.5rem; overflow:auto; }
 .kv td { border:none; padding:.3rem .6rem; }
 .muted { color:#666; }
 .badges span { margin-right:.35rem; }
</style>
</head>
<body>
  <nav>
    <a href="{{ url_for('index') }}" class="{{ 'active' if active=='usage' else '' }}">Usage Logs</a>
    <a href="{{ url_for('view_tasks') }}" class="{{ 'active' if active=='tasks' else '' }}">Tasks</a>
    <a href="{{ url_for('view_keys') }}" class="{{ 'active' if active=='keys' else '' }}">API Keys</a>
    <a href="{{ url_for('view_interactions') }}" class="{{ 'active' if active=='interactions' else '' }}">Interactions</a>
    <a href="{{ url_for('view_command_log') }}" class="{{ 'active' if active=='cmdlog' else '' }}">Command Log</a>
    <a href="{{ url_for('view_gemma_logs') }}" class="{{ 'active' if active=='logs' else '' }}">Gemma Logs</a>
  </nav>
  <div class="container">
    <h1>{{ title }}</h1>
    {% if toolbar %}{{ toolbar|safe }}{% endif %}
    {% if error %}
      <div class="no-data">Error: {{ error }}</div>
    {% elif data %}
      <table>
        <thead><tr>{% for h in headers %}<th>{{ h }}</th>{% endfor %}</tr></thead>
        <tbody>
          {% for row in data %}
            <tr>
              {% for item in row %}
                <td>{{ item|safe }}</td>
              {% endfor %}
            </tr>
          {% endfor %}
        </tbody>
      </table>
    {% else %}
      <div class="no-data">No entries found.</div>
    {% endif %}
  </div>
</body>
</html>
"""

# --- Routes: Simple pages (Usage, Tasks, Keys, Interactions) ---
@app.route('/')
def index():
    data, headers, error_message = [], [], None
    refresh = request.args.get('refresh', type=int)
    conn = get_db_connection()
    if not conn:
        error_message = "Failed to connect to the database."
    else:
        try:
            with conn.cursor() as cur:
                cur.execute("""SELECT id, key_name, task_id, request_timestamp, token_count, request_type
                               FROM usage_log ORDER BY request_timestamp DESC LIMIT 1000;""")
                headers = [d[0] for d in cur.description]
                for row in cur.fetchall():
                    row = list(row)
                    row[3] = convert_to_local_time(row[3])
                    data.append(row)
        except psycopg2.Error as e:
            error_message = f"Database query failed: {e}"
        finally:
            conn.close()

    return render_template_string(
        HTML_BASE, data=data, headers=headers, error=error_message,
        title="Database Usage Logs", active='usage', toolbar=None,
        refresh_seconds=refresh
    )

@app.route('/tasks')
def view_tasks():
    data, headers, error_message = [], [], None
    refresh = request.args.get('refresh', type=int)
    conn = get_db_connection()
    if not conn:
        error_message = "Failed to connect to the database."
    else:
        try:
            with conn.cursor() as cur:
                cur.execute("""SELECT id, status, last_updated, context
                               FROM tasks ORDER BY last_updated DESC LIMIT 1000;""")
                headers = [d[0] for d in cur.description]
                for row in cur.fetchall():
                    row = list(row)
                    row[2] = convert_to_local_time(row[2])
                    row[3] = f"<pre>{json.dumps(row[3], indent=2)}</pre>"
                    data.append(row)
        except psycopg2.Error as e:
            error_message = f"Database query failed: {e}"
        finally:
            conn.close()

    return render_template_string(
        HTML_BASE, data=data, headers=headers, error=error_message,
        title="Tasks", active='tasks', toolbar=None, refresh_seconds=refresh
    )

@app.route('/keys')
def view_keys():
    data, headers, error_message = [], [], None
    refresh = request.args.get('refresh', type=int)
    conn = get_db_connection()
    if not conn:
        error_message = "Failed to connect to the database."
    else:
        try:
            with conn.cursor() as cur:
                cur.execute("""SELECT key_name, daily_request_count, daily_token_total, last_used,
                                      quota_exhausted, disabled_until
                               FROM api_keys ORDER BY last_used DESC NULLS LAST;""")
                headers = [d[0] for d in cur.description]
                for row in cur.fetchall():
                    row = list(row)
                    row[3] = convert_to_local_time(row[3])
                    row[5] = convert_to_local_time(row[5])
                    row[4] = badge("exhausted", "#dc3545") if row[4] else badge("ok", "#28a745")
                    data.append(row)
        except psycopg2.Error as e:
            error_message = f"Database query failed: {e}"
        finally:
            conn.close()

    return render_template_string(
        HTML_BASE, data=data, headers=headers, error=error_message,
        title="API Key Status", active='keys', toolbar=None, refresh_seconds=refresh
    )

@app.route('/interactions')
def view_interactions():
    data, headers, error_message = [], [], None
    refresh = request.args.get('refresh', type=int)
    conn = get_db_connection()
    if not conn:
        error_message = "Failed to connect to the database."
    else:
        try:
            with conn.cursor() as cur:
                cur.execute("""SELECT id, task_id, prompt, response, request_timestamp
                               FROM interactions ORDER BY request_timestamp DESC LIMIT 1000;""")
                headers = [d[0] for d in cur.description]
                for row in cur.fetchall():
                    row = list(row)
                    row[4] = convert_to_local_time(row[4])
                    row[2] = f"<pre>{row[2]}</pre>" if row[2] else ""
                    row[3] = f"<pre>{row[3]}</pre>" if row[3] else ""
                    data.append(row)
        except psycopg2.Error as e:
            error_message = f"Database query failed: {e}"
        finally:
            conn.close()

    return render_template_string(
        HTML_BASE, data=data, headers=headers, error=error_message,
        title="All Interactions", active='interactions', toolbar=None, refresh_seconds=refresh
    )

# --- Command Log: filters, pagination, CSV, detail view ---
def command_log_toolbar(total, page, page_size):
    # Build a small filter/pager bar
    q = request.args.to_dict()
    html = f"""
    <form method="get" class="toolbar">
      <input type="text" name="search" placeholder="search task/command" value="{q.get('search','')}">
      <select name="status">
        <option value="">status</option>
        <option value="queued"   {'selected' if q.get('status')=='queued' else ''}>queued</option>
        <option value="running"  {'selected' if q.get('status')=='running' else ''}>running</option>
        <option value="completed"{'selected' if q.get('status')=='completed' else ''}>completed</option>
        <option value="failed"   {'selected' if q.get('status')=='failed' else ''}>failed</option>
      </select>
      <select name="agent_mode">
        <option value="">agent mode</option>
        <option value="Interactive" {'selected' if q.get('agent_mode')=='Interactive' else ''}>Interactive</option>
        <option value="Agentic"     {'selected' if q.get('agent_mode')=='Agentic' else ''}>Agentic</option>
        <option value="ReAct"       {'selected' if q.get('agent_mode')=='ReAct' else ''}>ReAct</option>
      </select>
      <select name="confirmed">
        <option value="">confirmed?</option>
        <option value="true"  {'selected' if q.get('confirmed')=='true' else ''}>true</option>
        <option value="false" {'selected' if q.get('confirmed')=='false' else ''}>false</option>
      </select>
      <input type="text" name="permissions" placeholder="permissions" value="{q.get('permissions','')}">
      <input type="number" min="1" max="500" name="page_size" value="{page_size}">
      <input type="number" min="1" name="page" value="{page}">
      <input type="number" min="0" name="refresh" placeholder="autorefresh (s)" value="{q.get('refresh','')}">
      <button type="submit">Apply</button>
      <a class="btn secondary" href="{url_for('view_command_log')}">Reset</a>
      <a class="btn" href="{url_for('command_log_csv')}?{request.query_string.decode('utf-8')}">Download CSV</a>
    </form>
    <div class="muted">Total: {total} &nbsp;|&nbsp;
      <a class="btn link" href="{set_qs(request.url, page=max(page-1,1))}">Prev</a>
      &nbsp;/&nbsp;
      <a class="btn link" href="{set_qs(request.url, page=page+1)}">Next</a>
    </div>
    """
    return html

@app.route('/command_log')
def view_command_log():
    data, headers, error_message = [], [], None

    # Pagination
    page = max(request.args.get('page', default=1, type=int), 1)
    page_size = max(min(request.args.get('page_size', default=50, type=int), 500), 1)
    offset = (page - 1) * page_size

    # Filters
    status = request.args.get('status')
    agent_mode = request.args.get('agent_mode')
    confirmed = request.args.get('confirmed')   # 'true'|'false'
    permissions = request.args.get('permissions')
    search = request.args.get('search')
    refresh = request.args.get('refresh', type=int)

    where, params = [], []
    if status:
        where.append("cl.status = %s"); params.append(status)
    if agent_mode:
        where.append("cl.agent_mode = %s"); params.append(agent_mode)
    if confirmed in ('true', 'false'):
        where.append("cl.user_confirmation = %s"); params.append(confirmed == 'true')
    if permissions:
        where.append("cl.permissions = %s"); params.append(permissions)
    if search:
        where.append("(cl.task_id ILIKE %s OR cl.command ILIKE %s)")
        params.extend([f"%{search}%", f"%{search}%"])
    where_sql = ("WHERE " + " AND ".join(where)) if where else ""
    order_sql = "ORDER BY COALESCE(cl.executed_at, cl.command_start_timestamp) DESC NULLS LAST, cl.id DESC"

    conn = get_db_connection()
    if not conn:
        return render_template_string(HTML_BASE, data=data, headers=headers, error="Failed to connect to the database.",
                                      title="Command Log", active='cmdlog', toolbar=None, refresh_seconds=refresh)

    try:
        with conn.cursor() as cur:
            # Count
            cur.execute(f"SELECT COUNT(*) FROM command_log cl {where_sql}", params)
            total = cur.fetchone()[0]

            # Page rows
            cur.execute(f"""
                SELECT
                    cl.id,
                    cl.task_id,
                    COALESCE(cl.executed_at, cl.command_start_timestamp) AS executed_at,
                    cl.command,
                    cl.permissions,
                    cl.user_confirmation,
                    cl.agent_mode,
                    cl.status,
                    cl.command_start_timestamp,
                    cl.command_end_timestamp,
                    (EXTRACT(EPOCH FROM (cl.command_end_timestamp - cl.command_start_timestamp)))::INT AS duration_sec,
                    co.success,
                    co.return_code,
                    LEFT(COALESCE(co.stdout, ''), 160) AS stdout_preview,
                    LEFT(COALESCE(co.stderr, ''), 160) AS stderr_preview
                FROM command_log cl
                LEFT JOIN command_output co ON co.command_id = cl.id
                {where_sql}
                {order_sql}
                LIMIT %s OFFSET %s
            """, params + [page_size, offset])

            headers = [d[0] for d in cur.description]
            for row in cur.fetchall():
                row = list(row)
                # timestamps
                row[2] = convert_to_local_time(row[2])
                row[8] = convert_to_local_time(row[8])
                row[9] = convert_to_local_time(row[9])
                # badges
                row[5] = badge(fmt_bool(row[5]), "#17a2b8")  # confirmed
                status_color = {"completed":"#28a745", "failed":"#dc3545", "running":"#ffc107", "queued":"#6c757d"}.get(row[7], "#6c757d")
                row[7] = badge(row[7], status_color)
                succ = row[11]
                if succ is True:
                    row[11] = badge("success", "#28a745")
                elif succ is False:
                    row[11] = badge("fail", "#dc3545")
                else:
                    row[11] = badge("—", "#6c757d")
                # link to detail
                row[0] = f'<a href="{url_for("command_detail", cmd_id=row[0])}">{row[0]}</a>'
                # preview blocks
                row[13] = f"<pre>{row[13]}</pre>" if row[13] else ""
                row[14] = f"<pre>{row[14]}</pre>" if row[14] else ""
                data.append(row)

        toolbar = command_log_toolbar(total, page, page_size)
        return render_template_string(
            HTML_BASE, data=data, headers=headers, error=error_message,
            title="Command Log", active='cmdlog', toolbar=toolbar, refresh_seconds=refresh
        )

    except psycopg2.Error as e:
        error_message = f"Database query failed: {e}"
        return render_template_string(HTML_BASE, data=data, headers=headers, error=error_message,
                                      title="Command Log", active='cmdlog', toolbar=None, refresh_seconds=refresh)
    finally:
        conn.close()

@app.route('/command_log.csv')
def command_log_csv():
    # Mirror filters from /command_log
    status = request.args.get('status')
    agent_mode = request.args.get('agent_mode')
    confirmed = request.args.get('confirmed')
    permissions = request.args.get('permissions')
    search = request.args.get('search')

    where, params = [], []
    if status:
        where.append("cl.status = %s"); params.append(status)
    if agent_mode:
        where.append("cl.agent_mode = %s"); params.append(agent_mode)
    if confirmed in ('true', 'false'):
        where.append("cl.user_confirmation = %s"); params.append(confirmed == 'true')
    if permissions:
        where.append("cl.permissions = %s"); params.append(permissions)
    if search:
        where.append("(cl.task_id ILIKE %s OR cl.command ILIKE %s)")
        params.extend([f"%{search}%", f"%{search}%"])
    where_sql = ("WHERE " + " AND ".join(where)) if where else ""
    order_sql = "ORDER BY COALESCE(cl.executed_at, cl.command_start_timestamp) DESC NULLS LAST, cl.id DESC"

    conn = get_db_connection()
    if not conn:
        return Response("DB connect failed", status=500)

    try:
        with conn.cursor() as cur:
            cur.execute(f"""
                SELECT
                    cl.id, cl.task_id, COALESCE(cl.executed_at, cl.command_start_timestamp) AS executed_at,
                    cl.command, cl.permissions, cl.user_confirmation, cl.agent_mode, cl.status,
                    cl.command_start_timestamp, cl.command_end_timestamp,
                    (EXTRACT(EPOCH FROM (cl.command_end_timestamp - cl.command_start_timestamp)))::INT AS duration_sec,
                    co.success, co.return_code, co.stdout, co.stderr
                FROM command_log cl
                LEFT JOIN command_output co ON co.command_id = cl.id
                {where_sql}
                {order_sql}
                LIMIT 5000
            """, params)
            headers = [d[0] for d in cur.description]
            buf = StringIO()
            w = csv.writer(buf)
            w.writerow(headers)
            for row in cur.fetchall():
                r = list(row)
                r[2] = convert_to_local_time(r[2])
                r[8] = convert_to_local_time(r[8])
                r[9] = convert_to_local_time(r[9])
                w.writerow(r)
    finally:
        conn.close()

    return Response(buf.getvalue(), mimetype='text/csv',
                    headers={"Content-Disposition": "attachment; filename=command_log.csv"})

@app.route('/command/<int:cmd_id>')
def command_detail(cmd_id):
    """Full detail view for a single command (prompt, stdout, stderr, timings)."""
    conn = get_db_connection()
    if not conn:
        return render_template_string(HTML_BASE, data=None, headers=None, error="DB connect failed",
                                      title=f"Command {cmd_id}", active='cmdlog', toolbar=None, refresh_seconds=None)
    try:
        with conn.cursor() as cur:
            cur.execute("""
                SELECT
                    cl.id, cl.task_id, cl.prompt, cl.command, cl.permissions, cl.user_confirmation,
                    cl.agent_mode, cl.status, cl.executed_at, cl.command_start_timestamp,
                    cl.command_end_timestamp, (EXTRACT(EPOCH FROM (cl.command_end_timestamp - cl.command_start_timestamp)))::INT AS duration_sec,
                    cl.thought, cl.observation, cl.parent_command_id,
                    co.success, co.return_code, co.stdout, co.stderr
                FROM command_log cl
                LEFT JOIN command_output co ON co.command_id = cl.id
                WHERE cl.id = %s
            """, (cmd_id,))
            row = cur.fetchone()
            if not row:
                return render_template_string(HTML_BASE, data=None, headers=None, error="Not found",
                                              title=f"Command {cmd_id}", active='cmdlog', toolbar=None, refresh_seconds=None)

            # Build detail HTML
            (rid, task_id, prompt, command, permissions, confirmed, agent_mode, status,
             executed_at, start_ts, end_ts, duration_sec, thought, observation, parent_id,
             success, return_code, stdout, stderr) = row

            status_color = {"completed":"#28a745", "failed":"#dc3545", "running":"#ffc107", "queued":"#6c757d"}.get(status, "#6c757d")
            badges_html = f'<div class="badges">{badge(status, status_color)} {badge(agent_mode or "—", "#6c757d")} {badge(("confirmed" if confirmed else "unconfirmed"), "#17a2b8")}</div>'

            meta_rows = [
                ("id", rid),
                ("task_id", task_id),
                ("permissions", permissions),
                ("return_code", return_code if return_code is not None else "—"),
                ("success", fmt_bool(bool(success)) if success is not None else "—"),
                ("executed_at", convert_to_local_time(executed_at) if executed_at else "—"),
                ("start", convert_to_local_time(start_ts) if start_ts else "—"),
                ("end", convert_to_local_time(end_ts) if end_ts else "—"),
                ("duration_sec", duration_sec if duration_sec is not None else "—"),
                ("parent_command_id", parent_id if parent_id is not None else "—"),
            ]
            kv = "<table class='kv'>"
            for k, v in meta_rows:
                kv += f"<tr><td class='muted'>{k}</td><td>{v}</td></tr>"
            kv += "</table>"

            toolbar = f"""
            <div class="toolbar">
              <a class="btn secondary" href="{url_for('view_command_log')}">Back to Command Log</a>
              <a class="btn" href="{url_for('command_log_csv')}?id={rid}">Download CSV (all)</a>
            </div>
            """

            html = f"""
            <div>{badges_html}{kv}</div>
            <h3>Prompt</h3>
            <pre>{(prompt or "")}</pre>
            <h3>Command</h3>
            <pre>{(command or "")}</pre>
            <h3>Thought</h3>
            <pre>{(thought or "—")}</pre>
            <h3>Observation</h3>
            <pre>{(observation or "—")}</pre>
            <h3>STDOUT</h3>
            <pre>{(stdout or "")}</pre>
            <h3>STDERR</h3>
            <pre>{(stderr or "")}</pre>
            """

            # Render inside base template
            return render_template_string(
                HTML_BASE.replace("{% if error %}", "{% if error %}"),  # keep structure
                data=[[html]], headers=["Details"], error=None,
                title=f"Command {rid}", active='cmdlog', toolbar=toolbar, refresh_seconds=None
            )

    except psycopg2.Error as e:
        return render_template_string(HTML_BASE, data=None, headers=None, error=f"DB error: {e}",
                                      title=f"Command {cmd_id}", active='cmdlog', toolbar=None, refresh_seconds=None)
    finally:
        conn.close()

# --- Logs Browser ---
@app.route('/gemma_logs', defaults={'filename': None})
@app.route('/gemma_logs/<path:filename>')
def view_gemma_logs(filename):
    if filename:
        if not os.path.isdir(LOGS_DIR):
            return "Log directory not found.", 404
        return send_from_directory(LOGS_DIR, filename)
    # list
    files = []
    if os.path.isdir(LOGS_DIR):
        files = [f for f in os.listdir(LOGS_DIR) if os.path.isfile(os.path.join(LOGS_DIR, f))]
        files.sort(reverse=True)
    items = "".join(f'<li><a href="{url_for("view_gemma_logs", filename=f)}">{f}</a></li>' for f in files)
    html = f"""
    <ul>{items or "<li>No log files found.</li>"}</ul>
    """
    return render_template_string(
        HTML_BASE, data=[[html]], headers=["Files"], error=None,
        title="Gemma Logs", active='logs', toolbar=None, refresh_seconds=None
    )

# --- Health ---
@app.route('/healthz')
def health():
    return Response("ok", 200)

if __name__ == '__main__':
    port = int(os.getenv('WEB_UI_PORT', '5002'))
    debug = os.getenv('WEB_UI_DEBUG', '0') == '1'
    app.run(host='0.0.0.0', port=port, debug=debug, use_reloader=False)
